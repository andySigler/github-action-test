# github-action-test

## Installing

1) Clone the repo
2) `cd` into repo directory
3) Install the `github_action_test` Python package, in editable (`-e`) mode

```commandline
git clone https://github.com/andySigler/github-action-test.git
cd github-action-test
python -m pip install -e .
```

## Developing

`github_action_test` is a Python module, and can be invoked from command line using the following syntax:

```commandline
python -m github_action_test.scripts.script_a
```

This works because the submodule `script_a` is organized like this:

```
github-action-test
    -> github_action_test
        -> scripts
            -> script_a
                -> __init__.py
                -> __main__.py
                -> .version
```

### __init__.py

This is the entry point for the `script_a` submodule, and must define a `main()` method:

```python
# __init___.py

def main():
    # code goes here
```

### __main__.py

This is the actual file that is called when running as submodule, using `python -m ...`

Every `__main__.py` file can simply contain the following few lines:
```python
# __main__.py
from . import main

if __name__ == '__main__':
    main()
```

This imports the `main()` method from `__init__.py`, and runs it.

### .version

This is a text file containing the current tagged version of this script.

For example, a script my have the version `A1.3`, which would be put inside the `.version` file like this:

```
A1.3
```

This file is read and used to create a unique version string for the script (and built executable).

## Release

### Versioning

Updates made to a script's version are done by editing its contained `.version` file.

When creating a new version, and pull-request should be made which contains only the update to the `.version` file. This makes it easier to have simultaneous pull-requests while preparing a version update.

### Building

Executables are generated for macOS and Windows, using a GithubAction workflow.

The `build_release` GithubAction workflow can be initiated at any time, to create a release:
1) Run workflow with input
   1) script name
2) Workflow sets up environment
3) Downloads repo
4) Generates a tag, and pushes to Github
   1) Generate tag name using Python (generate_tag_name_for_script())
   2) Compare with other tags to guarantee uniqueness
5) Builds script
6) Uploads EXE or ZIP

### Releasing

Download the EXE and ZIP artifacts generated by the workflow.

Navigate on Github to the newly generated tag. Click the `Edit` button.

Enter all applicable information.

Attach the EXE and ZIP files to this release, and publish.
