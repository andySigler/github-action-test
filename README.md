# github-action-test

## Installing

1) Clone the repo
2) `cd` into repo directory
3) Install the `github_action_test` Python package, in editable (`-e`) mode

```commandline
git clone https://github.com/andySigler/github-action-test.git
cd github-action-test
python -m pip install -e .
```

## Developing

`github_action_test` is a Python module:

```python
from github_action_test.utils import version

print(version.generate_script_version(__file__))
```

but also it's contained scripts can be ran from the command line:

```commandline
python github_action_test/production_test/script_a/main.py
```

### Miscellaneous Scripts

Scripts and sub-projects stored in `misc_scripts` can be organized however is useful. They can import from other parts of the `github_action_test` module, or use their own self contained modules and helpers.

Scripts here can be ran as normal:

```commandline
python github_action_test/misc_scripts/random_script/main.py
```

### Production Tests

Production tests are each given their own subfolder (for example, `script_a`). This production test subfolder requires a `.version` and `main.py` file:

```
github-action-test
    -> github_action_test
        -> production_tests
            -> script_a
                -> .version
                -> main.py
                -> helper.py
```

#### .version

This is a text file containing the current tagged version of this script.

For example, a script my have the version `A1.3`, which would be put inside the `.version` file like this:

```
A1.3
```

This file is read and used to create a unique version string for the script (and built executable).

#### main.py

This is the entry point for the `script_a` submodule. It is required to be named `main.py`, for use during PyInstaller builds:

```python
# main.py
from github_action_test.utils import version

if __name__ == '__main__':
    # code goes here
    print(version.generate_script_version(__file__))
```

#### Other Files

Other required files (like `helpers.py` in the example above) can also be included within a production test. These should be files/scripts that are only useful for this one test, and not used elsewhere in the `github_action_test` package.

## Release

Production releases are made on a per-test basis. For example, if the `script_a` test is ready for a release, we would create a release for just that one script call `script_a_<version>`, where `<version>` would be defined within the `.version` file.

The release process then includes the following:
1) Update that test's `.version` file, within its own separate pull-request
2) Use Github workflow to create a tag for the repository, naming the tag `<SCRIPT-NAME>_<SCRIPT-VERSION>`
3) Github workflow then builds (using `pyinstaller`) an executable for that script
4) Edit the tag on Github to publish it as a release, and attach the build artifacts as assets

### Versioning

Updates made to a script's version are done by editing its contained `.version` file.

When creating a new version, and pull-request should be made which contains only the update to the `.version` file. This makes it easier to have simultaneous pull-requests while preparing a version update.

### Building

Executables are generated for macOS and Windows, using a GithubAction workflow.

The `build_release` GithubAction workflow can be initiated at any time, to create a release:
1) Run workflow with input
   1) script name
2) Workflow sets up environment
3) Downloads repo
4) Generates a tag, and pushes to Github
   1) Generate tag name using Python (generate_tag_name_for_script())
   2) Compare with other tags to guarantee uniqueness
5) Builds script
6) Uploads EXE or ZIP

### Releasing

Download the EXE and ZIP artifacts generated by the workflow.

Navigate on Github to the newly generated tag. Click the `Edit` button.

Enter all applicable information.

Attach the EXE and ZIP files to this release, and publish.
